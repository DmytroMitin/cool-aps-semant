/* The following code was generated by JFlex 1.5.0-SNAPSHOT (+scala) on 4/20/23, 11:13 AM */

/* Cool.flex language lexer specification */


/**
 * This class is a scanner generated by
 * <a href="http://www.jflex.de/">JFlex</a> 1.5.0-SNAPSHOT (+scala)
 * on 4/20/23, 11:13 AM from the specification file
 * <tt>Cool.lex</tt>
 */
class CoolScanner(private var zzReader: java.io.Reader) extends Iterator[CoolTokens.YYToken] {
  def this(in: java.io.InputStream) = this(new java.io.InputStreamReader(in));

  /** This character denotes the end of file */
  val YYEOF: Int = -1;

  /** initial size of the lookahead buffer */
  private val ZZ_BUFFERSIZE: Int = 16384;

  /** lexical states */
  val YYINITIAL: Int = 0;
  val STRING: Int = 2;

  /**
   * ZZ_LEXSTATE[l] is the state in the DFA for the lexical state l
   * ZZ_LEXSTATE[l+1] is the state in the DFA for the lexical state l
   * at the beginning of a line
   * l is of the form l = 2*k, k a non negative integer
   */
  private val ZZ_LEXSTATE: Array[Int] = Array(
    0, 0, 1, 1
  );

  /**
   * Translates characters to character classes
   */
  private val ZZ_CMAP_PACKED: String =
    "\u0009\u0000\u0001\u0002\u0001\u0001\u0002\u0000\u0001\u0002\u0012\u0000\u0001\u0002\u0001\u0006\u0001\u0007\u0005\u0000" +
      "\u0002\u0006\u0001\n\u0004\u0006\u0001\u0009\u0001\u000e\u0009\u0008\u0002\u0006\u0001\u000b\u0001\u000c\u0001\u000d" +
      "\u0002\u0000\u0012\u0003\u0001$\u0007\u0003\u0001\u0000\u0001)\u0002\u0000\u0001\u0004\u0001\u0000\u0001\u0010" +
      "\u0001\"\u0001\u000f\u0001\u0014\u0001\u0012\u0001\u0015\u0001(\u0001\u001b\u0001\u0019\u0001&\u0001\'" +
      "\u0001\u0013\u0001\u001a\u0001\u0018\u0001\u001f\u0001!\u0001\u0005\u0001 \u0001\u0011\u0001\u0017\u0001\u001e" +
      "\u0001\u001c\u0001\u001d\u0001\u0016\u0001#\u0001%\u0001\u0006\u0001\u0000\u0001\u0006\uff82\u0000";

  /**
   * Translates characters to character classes
   */
  private val ZZ_CMAP: Array[Char] = zzUnpackCMap(ZZ_CMAP_PACKED);

  /**
   * Translates DFA states to action switch labels.
   */

  private val ZZ_ACTION_PACKED_0: String =
    "\u0002\u0000\u0001\u0001\u0002\u0002\u0001\u0003\u0001\u0001\u0001\u0004\u0001\u0005\u0001\u0006" +
      "\u0001\u0007\u0003\u0005\u0001\u0008\u0011\u0004\u0001\u0009\u0001\n\u0001\u000b\u0001\u000c" +
      "\u0002\u000d\u0001\u0000\u0001\u0002\u0001\u000e\u0001\u000f\u0001\u0010\u0001\u0011\u0001\u0012" +
      "\u0009\u0004\u0001\u0013\u0009\u0004\u0001\u0014\u000b\u0004\u0001\u0015\u0001\u0016\u0001\u0017" +
      "\u0001\u0018\u0001\u0019\u0001\u001a\u0001\u001b\u0001\u001c\u0001\u001d\u0001\u001e\u0001\u000e" +
      "\u0009\u0004\u0001\u001f\u0002\u0004\u0001 \u0004\u0004\u0001!\u0002\u0004\u0001\"" +
      "\u0003\u0004\u0001#\u0001$\n\u0004\u0001\u001e\u0001%\u0005\u0004\u0001&" +
      "\u0001\u0004\u0001\'\u0003\u0004\u0001(\u0002\u0004\u0001)\u0001*\u0001\u0004" +
      "\u0001+\u0003\u0004\u0001,\u0009\u0004\u0001\u001e\u0001-\u0001.\u0002\u0004" +
      "\u0001/\u0001\u0004\u00010\u00011\u0001\u0004\u00012\u00013\u0003\u0004" +
      "\u00014\u00015\u0007\u0004\u00016\u00017\u0001\u0004\u00018\u0003\u0004" +
      "\u00019\u0001\u0004\u0001:\u0001\u0004\u0001;\u0001\u0004\u0001<\u0004\u0004" +
      "\u0001=\u0001>\u0001?\u0003\u0004\u0001@\u0001A\u0001\u0004\u0001B" +
      "\u0001C\u0001D\u0001E\u0001\u0004\u0001F";

  private def zzUnpackAction(): Array[Int] = {
    val result: Array[Int] = new Array[Int](213);
    var offset: Int = 0;
    offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);
    return result;
  }

  private def zzUnpackAction(packed: String, offset: Int, result: Array[Int]): Int = {
    var i: Int = 0;
    /* index in packed string  */
    var j: Int = offset;
    /* index in unpacked array */
    val l: Int = packed.length();
    while (i < l) {
      var count: Int = packed.charAt(i);
      i += 1;
      var value: Int = packed.charAt(i);
      i += 1;
      do {
        result(j) = value; j += 1; count -= 1;
      } while (count > 0);
    }
    return j;
  }

  private val ZZ_ACTION: Array[Int] = zzUnpackAction();


  /**
   * Translates a state to a row index in the transition table
   */

  private val ZZ_ROWMAP_PACKED_0: String =
    "\u0000\u0000\u0000*\u0000T\u0000~\u0000\u00a8\u0000\u00d2\u0000\u00fc\u0000\u0126" +
      "\u0000~\u0000\u0150\u0000\u017a\u0000\u01a4\u0000\u01ce\u0000\u01f8\u0000\u0222\u0000\u024c" +
      "\u0000\u0276\u0000\u02a0\u0000\u02ca\u0000\u02f4\u0000\u031e\u0000\u0348\u0000\u0372\u0000\u039c" +
      "\u0000\u03c6\u0000\u03f0\u0000\u041a\u0000\u0444\u0000\u046e\u0000\u0498\u0000\u04c2\u0000\u04ec" +
      "\u0000\u0516\u0000~\u0000~\u0000\u0540\u0000\u056a\u0000\u00fc\u0000\u0594\u0000\u05be" +
      "\u0000\u05e8\u0000~\u0000~\u0000~\u0000\u0222\u0000\u0612\u0000\u063c\u0000\u0666" +
      "\u0000\u0690\u0000\u06ba\u0000\u06e4\u0000\u070e\u0000\u0738\u0000\u0762\u0000\u0126\u0000\u078c" +
      "\u0000\u07b6\u0000\u07e0\u0000\u080a\u0000\u0834\u0000\u085e\u0000\u0888\u0000\u08b2\u0000\u08dc" +
      "\u0000\u0126\u0000\u0906\u0000\u0930\u0000\u095a\u0000\u0984\u0000\u09ae\u0000\u09d8\u0000\u0a02" +
      "\u0000\u0a2c\u0000\u0a56\u0000\u0a80\u0000\u0aaa\u0000~\u0000~\u0000~\u0000~" +
      "\u0000~\u0000~\u0000~\u0000~\u0000~\u0000\u0ad4\u0000\u0afe\u0000\u0b28" +
      "\u0000\u0b52\u0000\u0b7c\u0000\u0ba6\u0000\u0bd0\u0000\u0bfa\u0000\u0c24\u0000\u0c4e\u0000\u0c78" +
      "\u0000\u0126\u0000\u0ca2\u0000\u0ccc\u0000\u0cf6\u0000\u0d20\u0000\u0d4a\u0000\u0d74\u0000\u0d9e" +
      "\u0000\u0126\u0000\u0dc8\u0000\u0df2\u0000\u0126\u0000\u0e1c\u0000\u0e46\u0000\u0e70\u0000\u0126" +
      "\u0000\u0126\u0000\u0e9a\u0000\u0ec4\u0000\u0eee\u0000\u0f18\u0000\u0f42\u0000\u0f6c\u0000\u0f96" +
      "\u0000\u0fc0\u0000\u0fea\u0000\u1014\u0000\u103e\u0000\u0126\u0000\u1068\u0000\u1092\u0000\u10bc" +
      "\u0000\u10e6\u0000\u1110\u0000\u0126\u0000\u113a\u0000\u0126\u0000\u1164\u0000\u118e\u0000\u11b8" +
      "\u0000\u0126\u0000\u11e2\u0000\u120c\u0000\u0126\u0000\u0126\u0000\u1236\u0000\u0126\u0000\u1260" +
      "\u0000\u128a\u0000\u12b4\u0000\u0126\u0000\u12de\u0000\u1308\u0000\u1332\u0000\u135c\u0000\u1386" +
      "\u0000\u13b0\u0000\u13da\u0000\u1404\u0000\u142e\u0000\u1458\u0000\u0126\u0000\u0126\u0000\u1482" +
      "\u0000\u14ac\u0000\u0126\u0000\u14d6\u0000\u0126\u0000\u1500\u0000\u152a\u0000\u0126\u0000\u0126" +
      "\u0000\u1554\u0000\u157e\u0000\u15a8\u0000\u0126\u0000\u0126\u0000\u15d2\u0000\u15fc\u0000\u1626" +
      "\u0000\u1650\u0000\u167a\u0000\u16a4\u0000\u16ce\u0000\u0126\u0000~\u0000\u16f8\u0000\u0126" +
      "\u0000\u1722\u0000\u174c\u0000\u1776\u0000\u0126\u0000\u17a0\u0000\u0126\u0000\u17ca\u0000\u0126" +
      "\u0000\u17f4\u0000\u0126\u0000\u181e\u0000\u1848\u0000\u1872\u0000\u189c\u0000\u0126\u0000\u0126" +
      "\u0000\u0126\u0000\u18c6\u0000\u18f0\u0000\u191a\u0000\u0126\u0000\u0126\u0000\u1944\u0000\u0126" +
      "\u0000\u0126\u0000\u0126\u0000\u0126\u0000\u196e\u0000\u0126";

  private def zzUnpackRowMap(): Array[Int] = {
    val result: Array[Int] = new Array[Int](213);
    var offset: Int = 0;
    offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);
    return result;
  }

  private def zzUnpackRowMap(packed: String, offset: Int, result: Array[Int]): Int = {
    var i: Int = 0;
    /* index in packed string  */
    var j: Int = offset;
    /* index in unpacked array */
    val l: Int = packed.length();
    while (i < l) {
      val high: Int = packed.charAt(i) << 16;
      i += 1;
      result(j) = high | packed.charAt(i);
      i += 1;
      j += 1;
    }
    return j;
  }

  private val ZZ_ROWMAP: Array[Int] = zzUnpackRowMap();

  /**
   * The transition table of the DFA
   */

  private val ZZ_TRANS_PACKED_0: String =
    "\u0001\u0003\u0001\u0004\u0001\u0005\u0001\u0006\u0001\u0007\u0001\u0008\u0001\u0009\u0001\n" +
      "\u0001\u000b\u0001\u000c\u0001\u0009\u0001\u000d\u0001\u000e\u0001\u0003\u0001\u000f\u0001\u0010" +
      "\u0001\u0011\u0001\u0012\u0001\u0013\u0001\u0014\u0001\u0015\u0001\u0016\u0001\u0008\u0001\u0017" +
      "\u0001\u0018\u0001\u0019\u0001\u001a\u0001\u0008\u0001\u001b\u0001\u001c\u0001\u0008\u0001\u001d" +
      "\u0001\u001e\u0001\u001f\u0001\u0008\u0001 \u0001\u0006\u0004\u0008\u0001\u0003\u0001!" +
      "\u0001\"\u0005!\u0001#!!\u0001$\u0001\u0003\u0003\u0000\u0001\u0003" +
      "\u0008\u0000\u0001\u0003\u001b\u0000\u0001\u0003,\u0000\u0001\u0005*\u0000\u0003\u0006" +
      "\u0002\u0000\u0001\u0006\u0005\u0000\u001b\u0006\u0001\u0000\u0001\u0003\u0002\u0000\u0001%" +
      "\u0001&\u0001%\u0002\u0000\u0001%\u0004\u0000\u0001\u0003\u001b%\u0001\u0003" +
      "\u0003\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u001b\u0008\u0008\u0000\u0001\'" +
      "*\u0000\u0001\u000b\u0005\u0000\u0001\u000b$\u0000\u0001(\u0001)+\u0000" +
      "\u0001*)\u0000\u0001+\u0001,$\u0000\u0001-\u0005\u0000\u0001-" +
      "\u001e\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0002\u0008\u0001.\u0002\u0008" +
      "\u0001/\u0015\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0014\u0008" +
      "\u00010\u0006\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0004\u0008" +
      "\u00011\u000b\u0008\u00012\n\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008" +
      "\u0005\u0000\u0005\u0008\u00013\u0002\u0008\u00014\u0012\u0008\u0004\u0000\u0003\u0008" +
      "\u0002\u0000\u0001\u0008\u0005\u0000\u0002\u0008\u00015\u0018\u0008\u0004\u0000\u0003\u0008" +
      "\u0002\u0000\u0001\u0008\u0005\u0000\u0004\u0008\u00016\u000c\u0008\u00017\u0009\u0008" +
      "\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0002\u0008\u00018\u0008\u0008" +
      "\u00019\u0005\u0008\u0001:\u0009\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008" +
      "\u0005\u0000\u000d\u0008\u0001;\u0004\u0008\u0001<\u0002\u0008\u0001=\u0005\u0008" +
      "\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0002\u0008\u0001>\u0001\u0008" +
      "\u0001?\u000b\u0008\u0001@\n\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008" +
      "\u0005\u0000\u0007\u0008\u0001A\u0004\u0008\u0001B\u000e\u0008\u0004\u0000\u0003\u0008" +
      "\u0002\u0000\u0001\u0008\u0005\u0000\u0002\u0008\u0001C\u0018\u0008\u0004\u0000\u0003\u0008" +
      "\u0002\u0000\u0001\u0008\u0005\u0000\u0002\u0008\u0001D\u0018\u0008\u0004\u0000\u0003\u0008" +
      "\u0002\u0000\u0001\u0008\u0005\u0000\u000b\u0008\u0001E\u0001\u0008\u0001F\u000d\u0008" +
      "\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u000e\u0008\u0001G\u0005\u0008" +
      "\u0001H\u0006\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0004\u0008" +
      "\u0001I\u0016\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0002\u0008" +
      "\u0001J\u000f\u0008\u0001K\u0008\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008" +
      "\u0005\u0000\u000b\u0008\u0001L\u000f\u0008\u0001\u0000\u0001!\u0001\u0000\u0005!" +
      "\u0001\u0000!!\u0001\u0000\u0001M\u0001N\u0005M\u0001O\u000dM" +
      "\u0001P\u0001M\u0001Q\u0001R\u0007M\u0001S\u0001M\u0001T" +
      "\u0006M\u0001U\u0003\u0000\u0003%\u0002\u0000\u0001%\u0005\u0000\u001b%" +
      "\u0008\u0000\u0001V\"\u0000\u0001(\u0001\u0000((\n)\u0001W" +
      "\u001f)\u0003\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0003\u0008\u0001X" +
      "\u0005\u0008\u0001Y\u0011\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000" +
      "\u0002\u0008\u0001Z\u0018\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000" +
      "\u0003\u0008\u0001[\u0017\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000" +
      "\u0002\u0008\u0001\\\u0018\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000" +
      "\u0013\u0008\u0001]\u0007\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000" +
      "\u0003\u0008\u0001^\u0017\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000" +
      "\u0009\u0008\u0001_\u0011\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000" +
      "\u0017\u0008\u0001`\u0003\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000" +
      "\u0007\u0008\u0001a\u0013\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000" +
      "\u0005\u0008\u0001b\u0015\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000" +
      "\n\u0008\u0001c\u0010\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000" +
      "\u0012\u0008\u0001d\u0008\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000" +
      "\u000b\u0008\u0001e\u0006\u0008\u0001f\u0008\u0008\u0004\u0000\u0003\u0008\u0002\u0000" +
      "\u0001\u0008\u0005\u0000\u0002\u0008\u0001g\u000d\u0008\u0001h\u0004\u0008\u0001i" +
      "\u0005\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0013\u0008\u0001j" +
      "\u0007\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0009\u0008\u0001k" +
      "\u0011\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u000f\u0008\u0001l" +
      "\u000b\u0008\u0004\u0000\u0003\u0008\u0002\u0000";

  private val ZZ_TRANS_PACKED_1: String =
    "\u0001\u0008\u0005\u0000\u0005\u0008\u0001m\u0015\u0008\u0004\u0000\u0003\u0008\u0002\u0000" +
      "\u0001\u0008\u0005\u0000\u0013\u0008\u0001n\u0007\u0008\u0004\u0000\u0003\u0008\u0002\u0000" +
      "\u0001\u0008\u0005\u0000\u0009\u0008\u0001o\u0011\u0008\u0004\u0000\u0003\u0008\u0002\u0000" +
      "\u0001\u0008\u0005\u0000\u0005\u0008\u0001p\u000c\u0008\u0001q\u0008\u0008\u0004\u0000" +
      "\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0009\u0008\u0001r\u0011\u0008\u0004\u0000" +
      "\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u000b\u0008\u0001s\u000f\u0008\u0004\u0000" +
      "\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0004\u0008\u0001t\u0016\u0008\u0004\u0000" +
      "\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0018\u0008\u0001u\u0002\u0008\u0004\u0000" +
      "\u0002\u0008\u0001v\u0002\u0000\u0001\u0008\u0005\u0000\u0009\u0008\u0001w\u0011\u0008" +
      "\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0001\u0008\u0001x\u0019\u0008" +
      "\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u000b\u0008\u0001y\u0005\u0008" +
      "\u0001z\u0009\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0004\u0008" +
      "\u0001{\u0016\u0008\u0001\u0000\u0007V\u0001|\"V\u0009)\u0001\u0004" +
      "\u0001W\u001f)\u0003\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0004\u0008" +
      "\u0001}\u0016\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0001\u0008" +
      "\u0001~\u0019\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0003\u0008" +
      "\u0001\u007f\u0017\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0009\u0008" +
      "\u0001\u0080\u0011\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0005\u0008" +
      "\u0001\u0081\u0015\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0004\u0008" +
      "\u0001\u0082\u0016\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0004\u0008" +
      "\u0001\u0083\u0016\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0004\u0008" +
      "\u0001\u0084\u0016\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0015\u0008" +
      "\u0001\u0085\u0005\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0003\u0008" +
      "\u0001\u0086\u0017\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0002\u0008" +
      "\u0001\u0087\u0018\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0016\u0008" +
      "\u0001\u0088\u0004\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0003\u0008" +
      "\u0001\u0089\u0017\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0011\u0008" +
      "\u0001\u008a\u0009\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u000b\u0008" +
      "\u0001\u008b\u000f\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0004\u0008" +
      "\u0001\u008c\u0016\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0004\u0008" +
      "\u0001\u008d\u0016\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u000b\u0008" +
      "\u0001\u008e\u000f\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0005\u0008" +
      "\u0001\u008f\u0015\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0005\u0008" +
      "\u0001\u0090\u000b\u0008\u0001\u0091\u0009\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008" +
      "\u0005\u0000\u0001\u0008\u0001\u0092\u0019\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008" +
      "\u0005\u0000\u000d\u0008\u0001\u0093\u000d\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008" +
      "\u0005\u0000\u0005\u0008\u0001\u0094\u0015\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008" +
      "\u0005\u0000\u0012\u0008\u0001\u0095\u0008\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008" +
      "\u0005\u0000\u0004\u0008\u0001\u0096\u0016\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008" +
      "\u0005\u0000\u0010\u0008\u0001\u0097\n\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008" +
      "\u0005\u0000\u0010\u0008\u0001\u0098\n\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008" +
      "\u0005\u0000\u0019\u0008\u0001\u0099\u0001\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008" +
      "\u0005\u0000\u000e\u0008\u0001\u009a\u000c\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008" +
      "\u0005\u0000\u0009\u0008\u0001\u009b\u0011\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008" +
      "\u0005\u0000\u0005\u0008\u0001\u009c\u0015\u0008\u0001\u0000\u0007V\u0001\u009d\"V" +
      "\u0003\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u000d\u0008\u0001\u009e\u000d\u0008" +
      "\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0003\u0008\u0001\u009f\u0017\u0008" +
      "\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0012\u0008\u0001\u00a0\u0008\u0008" +
      "\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0004\u0008\u0001\u00a1\u0016\u0008" +
      "\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0012\u0008\u0001\u00a2\u0008\u0008" +
      "\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\n\u0008\u0001\u00a3\u0010\u0008" +
      "\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0004\u0008\u0001\u00a4\u0016\u0008" +
      "\u0004\u0000\u0003\u0008";

  private val ZZ_TRANS_PACKED_2: String =
    "\u0002\u0000\u0001\u0008\u0005\u0000\u0005\u0008\u0001\u00a5\u0015\u0008\u0004\u0000\u0003\u0008" +
      "\u0002\u0000\u0001\u0008\u0005\u0000\u0011\u0008\u0001\u00a6\u0009\u0008\u0004\u0000\u0003\u0008" +
      "\u0002\u0000\u0001\u0008\u0005\u0000\u000f\u0008\u0001\u00a7\u000b\u0008\u0004\u0000\u0003\u0008" +
      "\u0002\u0000\u0001\u0008\u0005\u0000\u0009\u0008\u0001\u00a8\u0011\u0008\u0004\u0000\u0003\u0008" +
      "\u0002\u0000\u0001\u0008\u0005\u0000\u000e\u0008\u0001\u00a9\u000c\u0008\u0004\u0000\u0003\u0008" +
      "\u0002\u0000\u0001\u0008\u0005\u0000\u000b\u0008\u0001\u00aa\u000f\u0008\u0004\u0000\u0003\u0008" +
      "\u0002\u0000\u0001\u0008\u0005\u0000\u0012\u0008\u0001\u00ab\u0008\u0008\u0004\u0000\u0003\u0008" +
      "\u0002\u0000\u0001\u0008\u0005\u0000\u000d\u0008\u0001\u00ac\u000d\u0008\u0004\u0000\u0003\u0008" +
      "\u0002\u0000\u0001\u0008\u0005\u0000\u0004\u0008\u0001\u00ad\u0016\u0008\u0004\u0000\u0003\u0008" +
      "\u0002\u0000\u0001\u0008\u0005\u0000\u0012\u0008\u0001\u00ae\u0008\u0008\u0004\u0000\u0003\u0008" +
      "\u0002\u0000\u0001\u0008\u0005\u0000\u0001\u0008\u0001\u00af\u0019\u0008\u0004\u0000\u0003\u0008" +
      "\u0002\u0000\u0001\u0008\u0005\u0000\u000b\u0008\u0001\u00b0\u000f\u0008\u0004\u0000\u0003\u0008" +
      "\u0002\u0000\u0001\u0008\u0005\u0000\u0012\u0008\u0001\u00b1\u0008\u0008\u0004\u0000\u0003\u0008" +
      "\u0002\u0000\u0001\u0008\u0005\u0000\u0002\u0008\u0001\u00b2\u0018\u0008\u0004\u0000\u0003\u0008" +
      "\u0002\u0000\u0001\u0008\u0005\u0000\u0002\u0008\u0001\u00b3\u0018\u0008\u0004\u0000\u0003\u0008" +
      "\u0002\u0000\u0001\u0008\u0005\u0000\u0004\u0008\u0001\u00b4\u0016\u0008\u0004\u0000\u0003\u0008" +
      "\u0002\u0000\u0001\u0008\u0005\u0000\u0006\u0008\u0001\u00b5\u0014\u0008\u0001\u0000\u0007V" +
      "\u0001\u00b6\"V\u0003\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0002\u0008" +
      "\u0001\u00b7\u0018\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0006\u0008" +
      "\u0001\u00b8\u0014\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0006\u0008" +
      "\u0001\u00b9\u0014\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0005\u0008" +
      "\u0001\u00ba\u0015\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u000c\u0008" +
      "\u0001\u00bb\u000e\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0004\u0008" +
      "\u0001\u00bc\u0016\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0001\u0008" +
      "\u0001\u00bd\u0019\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0009\u0008" +
      "\u0001\u00be\u0011\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u000b\u0008" +
      "\u0001\u00bf\u000f\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0009\u0008" +
      "\u0001\u00c0\u0011\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0012\u0008" +
      "\u0001\u00c1\u0008\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\n\u0008" +
      "\u0001\u00c2\u0010\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u001a\u0008" +
      "\u0001\u00c3\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0009\u0008\u0001\u00c4" +
      "\u0011\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0001\u0008\u0001\u00c5" +
      "\u0019\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0001\u0008\u0001\u00c6" +
      "\u0019\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0003\u0008\u0001\u00c7" +
      "\u0017\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0015\u0008\u0001\u00c8" +
      "\u0005\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0004\u0008\u0001\u00c9" +
      "\u0016\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u000b\u0008\u0001\u00ca" +
      "\u000f\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0006\u0008\u0001\u00cb" +
      "\u0014\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0004\u0008\u0001\u00cc" +
      "\u0016\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0004\u0008\u0001\u00cd" +
      "\u0016\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0004\u0008\u0001\u00ce" +
      "\u0016\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0009\u0008\u0001\u00cf" +
      "\u0011\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0009\u0008\u0001\u00d0" +
      "\u0011\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0009\u0008\u0001\u00d1" +
      "\u0011\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0004\u0008\u0001\u00d2" +
      "\u0016\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0003\u0008\u0001\u00d3" +
      "\u0017\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0004\u0008\u0001\u00d4" +
      "\u0016\u0008\u0004\u0000\u0003\u0008\u0002\u0000\u0001\u0008\u0005\u0000\u0006\u0008\u0001\u00d5" +
      "\u0014\u0008\u0001\u0000";

  private def zzUnpackTrans(): Array[Int] = {
    val result: Array[Int] = new Array[Int](6552);
    var offset: Int = 0;
    offset = zzUnpackTrans(ZZ_TRANS_PACKED_0, offset, result);
    offset = zzUnpackTrans(ZZ_TRANS_PACKED_1, offset, result);
    offset = zzUnpackTrans(ZZ_TRANS_PACKED_2, offset, result);
    return result;
  }

  private def zzUnpackTrans(packed: String, offset: Int, result: Array[Int]): Int = {
    var i: Int = 0;
    /* index in packed string  */
    var j: Int = offset;
    /* index in unpacked array */
    val l: Int = packed.length();
    while (i < l) {
      var count: Int = packed.charAt(i);
      i += 1;
      var value: Int = packed.charAt(i);
      i += 1;
      value -= 1;
      do {
        result(j) = value; j += 1; count -= 1;
      } while (count > 0);
    }
    return j;
  }

  private val ZZ_TRANS: Array[Int] = zzUnpackTrans();


  /* error codes */
  private val ZZ_UNKNOWN_ERROR: Int = 0;
  private val ZZ_NO_MATCH: Int = 1;
  private val ZZ_PUSHBACK_2BIG: Int = 2;

  /* error messages for the codes above */
  private val ZZ_ERROR_MSG: Array[String] = Array(
    "Unkown internal scanner error",
    "Error: could not match input",
    "Error: pushback value was too large"
  );

  /**
   * ZZ_ATTRIBUTE[aState] contains the attributes of state <code>aState</code>
   */

  private val ZZ_ATTRIBUTE_PACKED_0: String =
    "\u0002\u0000\u0001\u0001\u0001\u0009\u0004\u0001\u0001\u0009\u0018\u0001\u0002\u0009\u0003\u0001" +
      "\u0001\u0000\u0002\u0001\u0003\u0009 \u0001\u0009\u0009`\u0001\u0001\u0009\u001f\u0001";

  private def zzUnpackAttribute(): Array[Int] = {
    val result: Array[Int] = new Array[Int](213);
    var offset: Int = 0;
    offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);
    return result;
  }

  private def zzUnpackAttribute(packed: String, offset: Int, result: Array[Int]): Int = {
    var i: Int = 0;
    /* index in packed string  */
    var j: Int = offset;
    /* index in unpacked array */
    val l: Int = packed.length();
    while (i < l) {
      var count: Int = packed.charAt(i);
      i += 1;
      var value: Int = packed.charAt(i);
      i += 1;
      do {
        result(j) = value; j += 1; count -= 1;
      } while (count > 0);
    }
    return j;
  }

  private val ZZ_ATTRIBUTE: Array[Int] = zzUnpackAttribute();


  /** the current state of the DFA */
  private var zzState: Int = 0;

  /** the current lexical state */
  private var zzLexicalState: Int = YYINITIAL;

  /** this buffer contains the current text to be matched and is
   * the source of the yytext() string */
  private var zzBuffer: Array[Char] = new Array(ZZ_BUFFERSIZE);

  /** the textposition at the last accepting state */
  private var zzMarkedPos: Int = 0;

  /** the current text position in the buffer */
  private var zzCurrentPos: Int = 0;

  /** startRead marks the beginning of the yytext() string in the buffer */
  private var zzStartRead: Int = 0;

  /** endRead marks the last character in the buffer, that has been read
   * from input */
  private var zzEndRead: Int = 0;

  /** number of newlines encountered up to the start of the matched text */
  private var yyline: Int = 0;

  /** the number of characters up to the start of the matched text */
  private var yychar: Int = 0;

  /**
   * the number of characters from the last newline up to the start of the
   * matched text
   */
  private var yycolumn: Int = 0;

  /**
   * zzAtBOL == true <=> the scanner is currently at the beginning of a line
   */
  private var zzAtBOL: Boolean = true;

  /** zzAtEOF == true <=> the scanner is at the EOF */
  private var zzAtEOF: Boolean = false;

  /* user code: */
  // These features are added to the Scanner class

  // ## The following comment is for students:
  // This constant is useful (but not directly) for limiting literal ints
  var maxint_string = "2147483647";

  // #(
  def int_string_ok(s: String): Boolean =
    if (s.length() < maxint_string.length()) true
    else if (maxint_string.length() < s.length()) false
    else (maxint_string.compareTo(s) >= 0);
  // #)
  // ## The following comment is for students:
  // You will find this attribute useful for building up strings.
  // See StringBuffer.cool
  var string_error: String = null;
  var string: StringBuffer = new StringBuffer();

  def symbol(n: String): Symbol = Symbol(n);

  var in_basic_file: Boolean = false;

  def set_in_basic_file(v: Boolean): Unit = in_basic_file = v;

  var io: IO = new IO();
  var lookahead: CoolTokens.YYToken = null;

  override def hasNext(): Boolean = {
    if (io.is_null(lookahead)) lookahead = yylex();
    lookahead match {
      case x: CoolTokens.YYEOF => false;
      case x: CoolTokens.YYToken => true;
    }
  };

  override def next(): CoolTokens.YYToken = {
    if (io.is_null(lookahead)) lookahead = yylex();
    var result: CoolTokens.YYToken = lookahead;
    lookahead = null;
    result
  };

  def getLineNumber(): Int = yyline + 1;


  /**
   * Creates a new scanner
   * There is also a java.io.InputStream version of this constructor.
   *
   * @param in the java.io.Reader to read input from.
   */

  /**
   * Unpacks the compressed character translation table.
   *
   * @param packed the packed character translation table
   * @return the unpacked character translation table
   */
  private def zzUnpackCMap(packed: String): Array[Char] = {
    val map: Array[Char] = new Array[Char](0x10000);
    var i: Int = 0;
    /* index in packed string  */
    var j: Int = 0;
    /* index in unpacked array */
    while (i < 118) {
      var count: Int = packed.charAt(i);
      i += 1;
      var value: Char = packed.charAt(i);
      i += 1;
      do {
        map(j) = value; j += 1; count -= 1;
      } while (count > 0);
    }
    return map;
  }


  /**
   * Refills the input buffer.
   *
   * @return <code>false</code>, iff there was new input.
   */
  private def zzRefill(): Boolean = {

    /* first: make room (if you can) */
    if (zzStartRead > 0) {
      System.arraycopy(zzBuffer, zzStartRead,
        zzBuffer, 0,
        zzEndRead - zzStartRead);

      /* translate stored positions */
      zzEndRead -= zzStartRead;
      zzCurrentPos -= zzStartRead;
      zzMarkedPos -= zzStartRead;
      zzStartRead = 0;
    }

    /* is the buffer big enough? */
    if (zzCurrentPos >= zzBuffer.length) {
      /* if not: blow it up */
      val newBuffer: Array[Char] = new Array(zzCurrentPos * 2);
      System.arraycopy(zzBuffer, 0, newBuffer, 0, zzBuffer.length);
      zzBuffer = newBuffer;
    }

    /* finally: fill the buffer with new input */
    val numRead: Int = zzReader.read(zzBuffer, zzEndRead,
      zzBuffer.length - zzEndRead);

    if (numRead > 0) {
      zzEndRead += numRead;
      return false;
    }
    // unlikely but not impossible: read 0 characters, but not at end of stream
    if (numRead == 0) {
      val c: Int = zzReader.read();
      if (c == -1) {
        return true;
      } else {
        zzBuffer(zzEndRead) = c.toChar;
        zzEndRead += 1
        return false;
      }
    }

    // numRead < 0
    return true;
  }


  /**
   * Closes the input stream.
   */
  def yyclose(): Unit = {
    zzAtEOF = true;
    /* indicate end of file */
    zzEndRead = zzStartRead;
    /* invalidate buffer    */

    if (zzReader != null)
      zzReader.close();
  }


  /**
   * Resets the scanner to read from a new input stream.
   * Does not close the old reader.
   *
   * All internal variables are reset, the old input stream
   * <b>cannot</b> be reused (internal buffer is discarded and lost).
   * Lexical state is set to <tt>ZZ_INITIAL</tt>.
   *
   * @param reader the new input stream
   */
  def yyreset(reader: java.io.Reader): Unit = {
    zzReader = reader;
    zzAtBOL = true;
    zzAtEOF = false;
    zzEndRead = 0;
    zzStartRead = 0;
    zzCurrentPos = 0;
    zzMarkedPos = 0;
    yyline = 0;
    yychar = 0;
    yycolumn = 0;
    zzLexicalState = YYINITIAL;
  }


  /**
   * Returns the current lexical state.
   */
  def yystate(): Int = {
    zzLexicalState;
  }


  /**
   * Enters a new lexical state
   *
   * @param newState the new lexical state
   */
  def yybegin(newState: Int): Unit = {
    zzLexicalState = newState;
  }


  /**
   * Returns the text matched by the current regular expression.
   */
  def yytext(): String = {
    new String(zzBuffer, zzStartRead, zzMarkedPos - zzStartRead);
  }


  /**
   * Returns the character at position <tt>pos</tt> from the
   * matched text.
   *
   * It is equivalent to yytext().charAt(pos), but faster
   *
   * @param pos the position of the character to fetch.
   *            A value from 0 to yylength()-1.
   * @return the character at position pos
   */
  def yycharat(pos: Int): Char = {
    zzBuffer(zzStartRead + pos);
  }


  /**
   * Returns the length of the matched text region.
   */
  def yylength(): Int = {
    zzMarkedPos - zzStartRead;
  }


  /**
   * Reports an error that occured while scanning.
   *
   * In a wellformed scanner (no or only correct usage of
   * yypushback(int) and a match-all fallback rule) this method
   * will only be called with things that "Can't Possibly Happen".
   * If this method is called, something is seriously wrong
   * (e.g. a JFlex bug producing a faulty scanner etc.).
   *
   * Usual syntax/scanner level error handling should be done
   * in error fallback rules.
   *
   * @param errorCode the code of the errormessage to display
   */
  private def zzScanError(errorCode: Int): Unit = {
    var message: String = null;
    try {
      message = ZZ_ERROR_MSG(errorCode);
    } catch {
      case e: ArrayIndexOutOfBoundsException =>
        message = ZZ_ERROR_MSG(ZZ_UNKNOWN_ERROR);
    }

    throw new Error(message);
  }


  /**
   * Pushes the specified amount of characters back into the input stream.
   *
   * They will be read again by then next call of the scanning method
   *
   * @param number the number of characters to be read again.
   *               This number must not be greater than yylength()!
   */
  def yypushback(number: Int): Unit = {
    if (number > yylength())
      zzScanError(ZZ_PUSHBACK_2BIG);

    zzMarkedPos -= number;
  }

  /** Nested class to simulate multi-level break */
  private case class ZZbreak(name: String) extends Throwable;

  /**
   * Resumes scanning until the next regular expression is matched,
   * the end of input is encountered or an I/O-Error occurs.
   *
   * @return the next token
   * @exception java.io.IOException  if any I/O-Error occurs
   */
  def yylex(): CoolTokens.YYToken = {
    var zzInput: Int = 0;
    var zzAction: Int = 0;

    // cached fields:
    var zzCurrentPosL: Int = 0;
    var zzMarkedPosL: Int = 0;
    var zzEndReadL: Int = zzEndRead;
    var zzBufferL: Array[Char] = zzBuffer;
    var zzCMapL: Array[Char] = ZZ_CMAP;

    val zzTransL: Array[Int] = ZZ_TRANS;
    val zzRowMapL: Array[Int] = ZZ_ROWMAP;
    val zzAttrL: Array[Int] = ZZ_ATTRIBUTE;

    while (true) {
      zzMarkedPosL = zzMarkedPos;

      var zzR: Boolean = false;
      zzCurrentPosL = zzStartRead
      while (zzCurrentPosL < zzMarkedPosL) {
        (zzBufferL(zzCurrentPosL)) match {
          case '\u000B'
               | '\u000C'
               | '\u0085'
               | '\u2028'
               | '\u2029' => {
            yyline += 1;
            zzR = false;
          }
          case '\r' => {
            yyline += 1;
            zzR = true;
          }
          case '\n' => {
            if (zzR)
              zzR = false;
            else {
              yyline += 1;
            }
          }
          case _ => {
            zzR = false;
          }
        }
        zzCurrentPosL += 1;
      }

      if (zzR) {
        // peek one character ahead if it is \n (if we have counted one line too much)
        var zzPeek: Boolean = false;
        if (zzMarkedPosL < zzEndReadL)
          zzPeek = zzBufferL(zzMarkedPosL) == '\n';
        else if (zzAtEOF)
          zzPeek = false;
        else {
          val eof: Boolean = zzRefill();
          zzEndReadL = zzEndRead;
          zzMarkedPosL = zzMarkedPos;
          zzBufferL = zzBuffer;
          if (eof)
            zzPeek = false;
          else
            zzPeek = zzBufferL(zzMarkedPosL) == '\n';
        }
        if (zzPeek) yyline -= 1;
      }
      zzAction = -1;

      {
        val p: Int = zzMarkedPosL;
        zzCurrentPosL = p;
        zzCurrentPos = p;
        zzStartRead = p;
      }

      zzState = ZZ_LEXSTATE(zzLexicalState);

      // set up zzAction for empty match case:
      var zzAttributes: Int = zzAttrL(zzState);
      if ((zzAttributes & 1) == 1) {
        zzAction = zzState;
      }


      /* zzForAction: */ try {
        while (true) {

          if (zzCurrentPosL < zzEndReadL) {
            zzInput = zzBufferL(zzCurrentPosL);
            zzCurrentPosL += 1;
          } else if (zzAtEOF) {
            zzInput = YYEOF;
            throw ZZbreak("zzForAction");
          }
          else {
            // store back cached positions
            zzCurrentPos = zzCurrentPosL;
            zzMarkedPos = zzMarkedPosL;
            val eof: Boolean = zzRefill();
            // get translated positions and possibly new buffer
            zzCurrentPosL = zzCurrentPos;
            zzMarkedPosL = zzMarkedPos;
            zzBufferL = zzBuffer;
            zzEndReadL = zzEndRead;
            if (eof) {
              zzInput = YYEOF;
              throw ZZbreak("zzForAction");
            }
            else {
              zzInput = zzBufferL(zzCurrentPosL);
              zzCurrentPosL += 1;
            }
          }
          val zzNext: Int = zzTransL(zzRowMapL(zzState) + zzCMapL(zzInput));
          if (zzNext == -1) throw ZZbreak("zzForAction");
          zzState = zzNext;

          zzAttributes = zzAttrL(zzState);
          if ((zzAttributes & 1) == 1) {
            zzAction = zzState;
            zzMarkedPosL = zzCurrentPosL;
            if ((zzAttributes & 8) == 8) throw ZZbreak("zzForAction");
          }

        }
      } catch {
        case ZZbreak("zzForAction") => ()
      }

      // store back cached position
      zzMarkedPos = zzMarkedPosL;

      (if (zzAction < 0) zzAction; else ZZ_ACTION(zzAction)) match {
        case 2 => {
          {
          }
        }
        case 71 => {}
        case 46 => {
          {
            return CoolTokens.CLASS();
          }
        }
        case 72 => {}
        case 19 => {
          {
            return CoolTokens.ERROR("Illegal keyword 'do'");
          }
        }
        case 73 => {}
        case 7 => {
          {
            var result: String = yytext();
            if (int_string_ok(result))
              return CoolTokens.INT_LIT(Symbol(result))
            else return CoolTokens.ERROR("Integer literal too big: " +
              result);
          }
        }
        case 74 => {}
        case 14 => {
          {
            return CoolTokens.ERROR("unterminated comment");
          }
        }
        case 75 => {}
        case 60 => {
          {
            return CoolTokens.ERROR("Illegal keyword 'return'");
          }
        }
        case 76 => {}
        case 41 => {
          {
            return CoolTokens.BOOL_LIT(true);
          }
        }
        case 77 => {}
        case 25 => {
          {
            string.append("\t");
          }
        }
        case 78 => {}
        case 39 => {
          {
            return CoolTokens.ERROR("Illegal keyword 'lazy'");
          }
        }
        case 79 => {}
        case 12 => {
          {
            yybegin(YYINITIAL);
            return CoolTokens.ERROR("Backslash at end of file");
          }
        }
        case 80 => {}
        case 37 => {
          {
            return CoolTokens.CASE();
          }
        }
        case 81 => {}
        case 68 => {
          {
            return CoolTokens.OVERRIDE();
          }
        }
        case 82 => {}
        case 6 => {
          {
            yybegin(STRING);
            string_error = "";
            string.setLength(0);
          }
        }
        case 83 => {}
        case 49 => {
          {
            return CoolTokens.ERROR("Illegal keyword 'final'");
          }
        }
        case 84 => {}
        case 28 => {
          {
            string.append("\b");
          }
        }
        case 85 => {}
        case 34 => {
          {
            return CoolTokens.NEW();
          }
        }
        case 86 => {}
        case 3 => {
          {
            return CoolTokens.TYPEID(Symbol(yytext()));
          }
        }
        case 87 => {}
        case 13 => {
          {
            return CoolTokens.ERROR("An identifier may not start with an underscore: ".concat(yytext()));
            /* return CoolTokens.OBJECTID(Symbol(yytext()));*/
          }
        }
        case 88 => {}
        case 32 => {
          {
            return CoolTokens.ERROR("Illegal keyword 'for'");
          }
        }
        case 89 => {}
        case 56 => {
          {
            return CoolTokens.ERROR("Illegal keyword 'sealed'");
          }
        }
        case 90 => {}
        case 58 => {
          {
            return CoolTokens.ERROR("Illegal keyword 'import'");
          }
        }
        case 91 => {}
        case 45 => {
          {
            return CoolTokens.ERROR("Illegal keyword 'catch'");
          }
        }
        case 92 => {}
        case 53 => {
          {
            return CoolTokens.WHILE();
          }
        }
        case 93 => {}
        case 17 => {
          {
            return CoolTokens.ARROW();
          }
        }
        case 94 => {}
        case 27 => {
          {
            string.append("\r");
          }
        }
        case 95 => {}
        case 70 => {
          {
            return CoolTokens.ERROR("Illegal keyword 'protected'");
          }
        }
        case 96 => {}
        case 18 => {
          {
            return CoolTokens.ERROR("Octal literal not supported: " +
              yytext());
          }
        }
        case 97 => {}
        case 61 => {
          {
            return CoolTokens.EXTENDS();
          }
        }
        case 98 => {}
        case 1 => {
          {
            return CoolTokens.ERROR("Illegal characters found on input: ".concat(yytext()));
          }
        }
        case 99 => {}
        case 15 => {
          {
            return CoolTokens.LE();
          }
        }
        case 100 => {}
        case 21 => {
          {
            string_error = "Illegal backslash escape: ".concat(yytext());
          }
        }
        case 101 => {}
        case 8 => {
          {
            return CoolTokens.INT_LIT(Symbol(yytext()));
          }
        }
        case 102 => {}
        case 62 => {
          {
            return CoolTokens.ERROR("Illegal keyword 'finally'");
          }
        }
        case 103 => {}
        case 67 => {
          {
            return CoolTokens.ERROR("Illegal keyword 'implicit'");
          }
        }
        case 104 => {}
        case 10 => {
          {
            yybegin(YYINITIAL);
            return CoolTokens.ERROR("Unterminated string at end of line");
          }
        }
        case 105 => {}
        case 4 => {
          {
            return CoolTokens.OBJECTID(Symbol(yytext()));
          }
        }
        case 106 => {}
        case 16 => {
          {
            return CoolTokens.EQEQ();
          }
        }
        case 107 => {}
        case 50 => {
          {
            return CoolTokens.ERROR("Illegal keyword 'throw'");
          }
        }
        case 108 => {}
        case 54 => {
          {
            return CoolTokens.ERROR("Illegal keyword 'yield'");
          }
        }
        case 109 => {}
        case 36 => {
          {
            return CoolTokens.VAR();
          }
        }
        case 110 => {}
        case 29 => {
          {
            string.append("\\");
          }
        }
        case 111 => {}
        case 42 => {
          {
            return CoolTokens.ERROR("Illegal keyword 'type'");
          }
        }
        case 112 => {}
        case 26 => {
          {
            string.append("\n");
          }
        }
        case 113 => {}
        case 40 => {
          {
            return CoolTokens.THIS();
          }
        }
        case 114 => {}
        case 5 => {
          {
            return CoolTokens.YYCHAR(yytext.charAt(0));
          }
        }
        case 115 => {}
        case 35 => {
          {
            return CoolTokens.ERROR("Illegal keyword 'val'");
          }
        }
        case 116 => {}
        case 65 => {
          {
            return CoolTokens.ERROR("Illegal keyword 'private'");
          }
        }
        case 117 => {}
        case 11 => {
          {
            yybegin(YYINITIAL);
            if (string_error == "")
              return CoolTokens.STR_LIT(symbol(string.toString()))
            else return CoolTokens.ERROR(string_error)
          }
        }
        case 118 => {}
        case 59 => {
          {
            return CoolTokens.ERROR("Illegal keyword 'object'");
          }
        }
        case 119 => {}
        case 23 => {
          {
            string.append("\"");
          }
        }
        case 120 => {}
        case 24 => {
          {
            string.append("\f");
          }
        }
        case 121 => {}
        case 20 => {
          {
            return CoolTokens.IF();
          }
        }
        case 122 => {}
        case 64 => {
          {
            return CoolTokens.ERROR("Illegal keyword 'package'");
          }
        }
        case 123 => {}
        case 47 => {
          {
            return CoolTokens.SUPER();
          }
        }
        case 124 => {}
        case 48 => {
          {
            return CoolTokens.BOOL_LIT(false);
          }
        }
        case 125 => {}
        case 22 => {
          {
            string_error = "Newlines cannot be escaped"
          }
        }
        case 126 => {}
        case 33 => {
          {
            return CoolTokens.ERROR("Illegal keyword 'try'");
          }
        }
        case 127 => {}
        case 44 => {
          {
            return CoolTokens.ERROR("Illegal keyword 'with'");
          }
        }
        case 128 => {}
        case 63 => {
          {
            return CoolTokens.ERROR("Illegal keyword 'forSome'");
          }
        }
        case 129 => {}
        case 57 => {
          {
            if (!in_basic_file) {
              return CoolTokens.ERROR("Keyword 'native' may only be used in basic classes");
            }
            return CoolTokens.NATIVE();
          }
        }
        case 130 => {}
        case 55 => {
          {
            var n: Int = yytext.length();
            return CoolTokens.STR_LIT(symbol(yytext.substring(3, n - 3)));
          }
        }
        case 131 => {}
        case 66 => {
          {
            return CoolTokens.ERROR("Illegal keyword 'abstract'");
          }
        }
        case 132 => {}
        case 38 => {
          {
            return CoolTokens.ELSE();
          }
        }
        case 133 => {}
        case 9 => {
          {
            string.append(yytext());
          }
        }
        case 134 => {}
        case 51 => {
          {
            return CoolTokens.ERROR("Illegal keyword 'trait'");
          }
        }
        case 135 => {}
        case 69 => {
          {
            return CoolTokens.ERROR("Illegal keyword 'requires'");
          }
        }
        case 136 => {}
        case 31 => {
          {
            return CoolTokens.DEF();
          }
        }
        case 137 => {}
        case 52 => {
          {
            return CoolTokens.MATCH();
          }
        }
        case 138 => {}
        case 30 => {
          {
            return CoolTokens.ERROR("Unterminated long string literal");
          }
        }
        case 139 => {}
        case 43 => {
          {
            return CoolTokens.NULL();
          }
        }
        case 140 => {}
        case _ =>
          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
            zzAtEOF = true;
            (zzLexicalState) match {
              case YYINITIAL => {
                {
                  return CoolTokens.YYEOF();
                }
              }
              case 214 => {}
              case STRING => {
                {
                  yybegin(YYINITIAL);
                  return CoolTokens.ERROR("Unterminated string at end of file");
                }
              }
              case 215 => {}
              case _ => {
                return null;
              }
            }
          } else {
            zzScanError(ZZ_NO_MATCH);
          }
      }
    }
    throw new RuntimeException("NOT REACHED");
  }


}
